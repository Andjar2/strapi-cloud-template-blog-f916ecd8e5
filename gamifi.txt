 Secci√≥n Noticias (Articulos)
üìà Suma de puntos
Acci√≥n	Puntos	L√≠mite diario
Visitar la secci√≥n por la ma√±ana	+10	1 vez por d√≠a
Visitar la secci√≥n por la tarde	+10	1 vez por d√≠a
Leer una noticia	+1	Hasta 10 noticias
Comentar en una noticia	+2	Hasta 10 comentarios
Votar positivamente un comentario	+1	Hasta 10 votos emitidos
Recibir un voto positivo en tu comentario	+1	Hasta 10 votos recibidos

üìâ Resta de puntos
Acci√≥n	Puntos
Recibir voto negativo en tu comentario	-1
Comentario eliminado por spam/moderaci√≥n	-5

üí¨ Secci√≥n Foro
üìà Suma de puntos
Acci√≥n	Puntos	L√≠mite diario
Visitar la secci√≥n del foro	+15	1 vez por d√≠a
Crear un nuevo topic	+5	Hasta 3 por d√≠a
Comentar en un topic	+2	Hasta 10 comentarios
Reaccionar a un mensaje	+1	Hasta 10 reacciones emitidas
Recibir una reacci√≥n en un mensaje	+1	Sin l√≠mite
Responder una pregunta (tipo de topic especial)	+3	Hasta 10 respuestas

üìâ Resta de puntos
Acci√≥n	Puntos
Recibir una reacci√≥n negativa en un mensaje	-1
Post eliminado por spam/moderaci√≥n	-5

EXTRAS
Seguir en Instagram (verificar automaticamente) +100
Dar Like en Instagram (verificar automaticamente) +2 Limite diario 10 puntos
Seguir en Facebook (verificar automaticamente) +100
Usuario no gana puntos en un dia -50 


MEC√ÅNICAS EXTRA 
Niveles de usuario (seg√∫n puntos acumulados)
Nivel	Requisitos
Novato	0 ‚Äì 199 pts
Hincha Activo	200 ‚Äì 499 pts
Fan√°tico	500 ‚Äì 999 pts
√çdolo	1000+ pts

Insignias (Badges)
Nombre	Condici√≥n
Primer Gol	Primer comentario o topic
Capit√°n del Foro	100 publicaciones en el foro
Comentarista del Mes	+200 puntos en comentarios ese mes
Votado al √Ålbum	50 votos positivos acumulados

// src/components/UserNav.tsx
"use client";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useAuth } from "@/hooks/use-auth";
import Link from "next/link";
import { auth } from "@/lib/firebase";
import { signOut } from "firebase/auth";
import NotificationsDropdown from "./NotificationsDropdown";

export default function UserNav() {
  const { user, userProfile, loading } = useAuth();

  // Log para depuraci√≥n: muestra el estado actual de las variables
  console.log("UserNav render - Estado actual:", { user, userProfile, loading });

  const handleLogout = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error("Error al cerrar sesi√≥n:", error);
    }
  };

  // 1. Si el contexto est√° cargando, muestra un bot√≥n de carga
  if (loading) {
    return <Button variant="ghost" size="sm">Cargando...</Button>;
  }

  // 2. Si no hay usuario autenticado, muestra el bot√≥n de iniciar sesi√≥n
  if (!user) {
    return (
      <Link href="/login" passHref>
        <Button variant="default">Iniciar Sesi√≥n</Button>
      </Link>
    );
  }
  
  // 3. Si hay un usuario pero el perfil a√∫n no se ha cargado (estado transitorio), muestra "Cargando..."
  // Esto deber√≠a ser muy breve si el AuthContext funciona correctamente.
  if (!userProfile) {
    console.warn("UserNav: Usuario autenticado pero perfil no disponible. Mostrando cargando...");
    return <Button variant="ghost" size="sm">Cargando...</Button>;
  }

  // 4. Si el usuario y el perfil est√°n disponibles, muestra el men√∫ de usuario
  const profileLink = `/profile/@${userProfile.displayName}`;

  return (
    <div className="flex items-center space-x-2">
        <NotificationsDropdown />
        <DropdownMenu>
        <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="relative h-8 w-8 rounded-full">
            <Avatar className="h-8 w-8">
                <AvatarImage src={userProfile.photoURL || ""} alt={userProfile.displayName || "User"} />
                <AvatarFallback>{userProfile.displayName?.[0] || 'U'}</AvatarFallback>
            </Avatar>
            </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-56" align="end" forceMount>
            <DropdownMenuLabel className="font-normal">
            <div className="flex flex-col space-y-1">
                <p className="text-sm font-medium leading-none">{userProfile.displayName}</p>
                <p className="text-xs leading-none text-muted-foreground">
                {user.email}
                </p>
            </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuGroup>
            <Link href={profileLink} passHref>
                <DropdownMenuItem>
                Perfil
                </DropdownMenuItem>
            </Link>
            <Link href="/profile/edit" passHref>
                <DropdownMenuItem>
                Ajustes
                </DropdownMenuItem>
            </Link>
            </DropdownMenuGroup>
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={handleLogout}>
            Cerrar sesi√≥n
            </DropdownMenuItem>
        </DropdownMenuContent>
        </DropdownMenu>
    </div>
  );
}
// src/components/PostCard.tsx
import Link from 'next/link';
import { Post, UserProfile } from '@/types';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  MessageSquare, ThumbsUp, Medal, ShieldAlert, Star, TrendingUp, ShieldCheck, Share2, MoreVertical, Edit, Trash2
} from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/hooks/use-toast';
import { getLevelName, updateUserStats } from '@/lib/gamification';
import { db } from '@/lib/firebase';
import { doc, runTransaction, collection, getDoc, updateDoc, deleteDoc, writeBatch } from 'firebase/firestore';
import { useState, useEffect } from 'react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface PostCardProps {
    post: Post;
    isDetailPage?: boolean;
    onReport?: (contentId: string, authorId: string) => void;
    onDelete?: () => void;
}

const PostCard = ({ post, isDetailPage = false, onReport, onDelete }: PostCardProps) => {
    const { userProfile } = useAuth();
    const { toast } = useToast();
    
    const [authorProfile, setAuthorProfile] = useState<Partial<UserProfile> | null>(post.authorProfile || null);
    const [isEditing, setIsEditing] = useState(false);
    const [editedTitle, setEditedTitle] = useState(post.title);
    const [editedContent, setEditedContent] = useState(post.content);

    useEffect(() => {
        const fetchAuthorProfile = async () => {
            if (!post.authorProfile && post.authorId) {
                const userDocRef = doc(db, 'users', post.authorId);
                const userDoc = await getDoc(userDocRef);
                if (userDoc.exists()) {
                    setAuthorProfile(userDoc.data() as UserProfile);
                }
            }
        };
        fetchAuthorProfile();
    }, [post.authorId, post.authorProfile]);

    const handleEdit = async () => {
        if (!editedTitle || !editedContent) {
            toast({ title: "Error", description: "El t√≠tulo y el contenido no pueden estar vac√≠os.", variant: "destructive" });
            return;
        }
        try {
            const postRef = doc(db, 'posts', post.id);
            await updateDoc(postRef, {
                title: editedTitle,
                content: editedContent
            });
            toast({ title: "Publicaci√≥n actualizada" });
            setIsEditing(false);
        } catch (error) {
            console.error("Error actualizando la publicaci√≥n:", error);
            toast({ title: "Error", description: "No se pudo actualizar la publicaci√≥n.", variant: "destructive" });
        }
    };

    const handleDelete = async () => {
        if (window.confirm("¬øEst√°s seguro de que quieres eliminar esta publicaci√≥n? Se restar√°n los puntos al autor original. Esta acci√≥n no se puede deshacer.")) {
            try {
                await updateUserStats(post.authorId, 'CREATE_POST', 'subtract');
                await deleteDoc(doc(db, 'posts', post.id));
                if (onDelete) onDelete();
                toast({ title: "Publicaci√≥n eliminada" });
                if (isDetailPage) window.location.href = '/forum';
            } catch (error) {
                console.error("Error eliminando la publicaci√≥n:", error);
                toast({ title: "Error", description: "No se pudo eliminar la publicaci√≥n.", variant: "destructive" });
            }
        }
    };
    
    const handleShare = async (platform: 'Twitter' | 'Facebook' | 'CopyLink') => {
        const postUrl = `${window.location.origin}/forum/post/${post.slug}`; // Use slug
        let shareUrl = '';
        switch (platform) {
            case 'Twitter':
                shareUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(postUrl)}&text=${encodeURIComponent(post.title)}`;
                break;
            case 'Facebook':
                shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(postUrl)}`;
                break;
            case 'CopyLink':
                await navigator.clipboard.writeText(postUrl);
                toast({ title: '¬°Enlace copiado al portapapeles!' });
                return;
        }
        window.open(shareUrl, '_blank', 'noopener,noreferrer');
    };
    
    const contentToShow = isDetailPage ? post.content : `${post.content.substring(0, 200)}...`;
    const levelName = authorProfile ? (typeof authorProfile.level === 'number' ? getLevelName(authorProfile.level) : authorProfile.level) : 'Debutante';
    const canManage = userProfile && (userProfile.role === 'admin' || userProfile.role === 'moderator' || userProfile.uid === post.authorId);

    return (
        <Card className="bg-gray-900 border-gray-700 overflow-hidden">
            <div className="flex">
                <div className="w-1/4 sm:w-1/5 md:w-1/6 bg-gray-800 p-4 flex flex-col items-center justify-center text-center">
                    <Link href={`/profile/${post.authorId}`} passHref>
                        <Avatar className="h-16 w-16 mb-2 cursor-pointer">
                            <AvatarImage src={authorProfile?.photoURL} alt={post.author} />
                            <AvatarFallback>{post.author.charAt(0)}</AvatarFallback>
                        </Avatar>
                    </Link>
                    <h4 className="font-bold text-white hover:underline">
                        <Link href={`/profile/${post.authorId}`}>{post.author}</Link>
                    </h4>
                    {authorProfile && (
                        <div className="flex flex-col items-center gap-1 mt-2">
                           <Badge variant="secondary">{levelName}</Badge>
                            <div className="text-xs text-gray-400 mt-1 space-y-1">
                                <div className="flex items-center gap-1"><Star size={14} />{authorProfile.points || 0} Pts</div>
                                <div className="flex items-center gap-1"><TrendingUp size={14} />{authorProfile.postCount || 0} Posts</div>
                            </div>
                        </div>
                    )}
                </div>

                <div className="w-3/4 sm:w-4/5 md:w-5/6 p-4 flex flex-col">
                    <CardHeader className="p-0 flex-row justify-between items-start">
                        <div>
                            {isEditing ? (
                                <Input
                                    value={editedTitle}
                                    onChange={(e) => setEditedTitle(e.target.value)}
                                    className="text-xl bg-gray-700"
                                />
                            ) : (
                                <CardTitle>
                                    <Link href={`/forum/post/${post.slug}`} className="text-xl text-orange-500 hover:underline">{post.title}</Link>
                                </CardTitle>
                            )}
                            <p className="text-xs text-gray-400">
                                Publicado el {post.createdAt ? new Date(post.createdAt.seconds * 1000).toLocaleString('es-ES') : '...'}
                            </p>
                        </div>
                        {canManage && !isEditing && (
                            <DropdownMenu>
                                <DropdownMenuTrigger asChild>
                                    <Button variant="ghost" size="icon"><MoreVertical className="h-4 w-4" /></Button>
                                </DropdownMenuTrigger>
                                <DropdownMenuContent>
                                    <DropdownMenuItem onClick={() => setIsEditing(true)}>
                                        <Edit className="mr-2 h-4 w-4" />
                                        <span>Editar</span>
                                    </DropdownMenuItem>
                                    <DropdownMenuItem onClick={handleDelete} className="text-red-500">
                                        <Trash2 className="mr-2 h-4 w-4" />
                                        <span>Eliminar</span>
                                    </DropdownMenuItem>
                                </DropdownMenuContent>
                            </DropdownMenu>
                        )}
                    </CardHeader>
                    <CardContent className="p-0 pt-2 flex-grow">
                        {isEditing ? (
                            <Textarea
                                value={editedContent}
                                onChange={(e) => setEditedContent(e.target.value)}
                                className="bg-gray-700 min-h-[150px]"
                                rows={6}
                            />
                        ) : (
                            <>
                                <p className="text-gray-300 whitespace-pre-wrap">{contentToShow}</p>
                                {!isDetailPage && post.content.length > 200 && (
                                    <Link href={`/forum/post/${post.slug}`} className="text-orange-500 hover:underline text-sm font-bold mt-2 inline-block">
                                        Ver discusi√≥n completa
                                    </Link>
                                )}
                            </>
                        )}
                    </CardContent>
                    <CardFooter className="p-0 pt-4 flex justify-between items-center text-gray-400">
                        {isEditing ? (
                            <div className="flex gap-2">
                                <Button onClick={handleEdit}>Guardar</Button>
                                <Button variant="outline" onClick={() => setIsEditing(false)}>Cancelar</Button>
                            </div>
                        ) : (
                            <>
                                <div className="flex items-center gap-1 sm:gap-2">
                                   </div>
                                <div className="flex items-center gap-2">
                                    <Link href={`/forum/post/${post.slug}`} className="flex items-center gap-1 text-xs hover:underline">
                                        <MessageSquare size={14} /> {post.commentCount || 0} Comentarios
                                    </Link>
                                    <DropdownMenu>
                                        <DropdownMenuTrigger asChild><Button variant="ghost" size="sm"><Share2 size={14} className="mr-1" /> Compartir</Button></DropdownMenuTrigger>
                                        <DropdownMenuContent>
                                            <DropdownMenuItem onClick={() => handleShare('Twitter')}>Twitter</DropdownMenuItem>
                                            <DropdownMenuItem onClick={() => handleShare('Facebook')}>Facebook</DropdownMenuItem>
                                            <DropdownMenuItem onClick={() => handleShare('CopyLink')}>Copiar Enlace</DropdownMenuItem>
                                        </DropdownMenuContent>
                                    </DropdownMenu>
                                </div>
                            </>
                        )}
                    </CardFooter>
                </div>
            </div>
        </Card>
    );
};

export default PostCard;
import { doc, runTransaction, increment } from 'firebase/firestore';
import { db } from './firebase';
import { UserProfile } from '@/types';

export type GamificationAction =
  | 'CREATE_POST'
  | 'CREATE_ARTICLE'
  | 'CREATE_COMMENT'
  | 'CREATE_ARTICLE_COMMENT'
  | 'RECEIVE_LIKE'
  | 'RECEIVE_GOLAZO'
  | 'RECEIVE_RED_CARD'
  | 'SOCIAL_SHARE';

export type GamificationOperation = 'add' | 'subtract';

const POINTS_CONFIG: Record<GamificationAction, number> = {
  CREATE_POST: 10,
  CREATE_ARTICLE: 50,
  CREATE_COMMENT: 5,
  CREATE_ARTICLE_COMMENT: 5,
  RECEIVE_LIKE: 2,
  RECEIVE_GOLAZO: 5,
  RECEIVE_RED_CARD: -10,
  SOCIAL_SHARE: 15,
};

const LEVELS_CONFIG = [
    { level: 1, name: "Debutante", points: 0 },
    { level: 2, name: "Promesa", points: 100 },
    { level: 3, name: "Titular", points: 300 },
    { level: 4, name: "Estrella", points: 700 },
    { level: 5, name: "Leyenda", points: 1500 },
];

export const getLevel = (points: number) => {
    const currentLevel = LEVELS_CONFIG.slice().reverse().find(l => points >= l.points);
    return currentLevel ? currentLevel.level : 1;
};
  
export const getLevelName = (level: number) => {
    const currentLevel = LEVELS_CONFIG.find(l => l.level === level);
    return currentLevel ? currentLevel.name : 'Debutante';
};

export const updateUserStats = async (
    userId: string,
    action: GamificationAction,
    operation: GamificationOperation = 'add'
  ) => {
    if (!userId) return;
  
    const userDocRef = doc(db, 'users', userId);
  
    try {
      await runTransaction(db, async (transaction) => {
        const userDoc = await transaction.get(userDocRef);
        if (!userDoc.exists()) {
          console.error("Gamification Error: User document not found for ID:", userId);
          return;
        }
        
        const userData = userDoc.data() as UserProfile;
        const multiplier = operation === 'add' ? 1 : -1;
        const pointsToChange = (POINTS_CONFIG[action] || 0) * multiplier;
        const newPoints = (userData.points || 0) + pointsToChange;
        
        const newLevelNumber = getLevel(newPoints);
        const newLevelName = getLevelName(newLevelNumber);

        const updateData: { [key: string]: any } = {
          points: newPoints,
          level: newLevelName,
        };
  
        const countIncrement = operation === 'add' ? 1 : -1;

        switch (action) {
          case 'CREATE_POST':
            updateData.postCount = increment(countIncrement);
            break;
          case 'CREATE_ARTICLE':
            updateData.articleCount = increment(countIncrement);
            break;
          case 'CREATE_COMMENT':
          case 'CREATE_ARTICLE_COMMENT':
            updateData.commentCount = increment(countIncrement);
            break;
          case 'SOCIAL_SHARE':
             if (operation === 'add') {
                updateData.shareCount = increment(1);
            }
            break;
        }
  
        transaction.update(userDocRef, updateData);
      });
    } catch (error) {
      console.error(`Gamification Error updating stats for action ${action}:`, error);
    }
  };
  
  export const updateReactionStats = async (userId: string, reactionType: 'like' | 'golazo' | 'redCard', incrementValue: boolean) => {
    if (!userId) return;
  
    const userDocRef = doc(db, 'users', userId);
    const value = incrementValue ? 1 : -1;
  
    try {
      await runTransaction(db, async (transaction) => {
        const userDoc = await transaction.get(userDocRef);
        if (!userDoc.exists()) {
          console.error("Gamification Error: User document not found for ID:", userId);
          return;
        }
  
        const userData = userDoc.data() as UserProfile;
        const action = reactionType === 'like' ? 'RECEIVE_LIKE' : reactionType === 'golazo' ? 'RECEIVE_GOLAZO' : 'RECEIVE_RED_CARD';
        const pointsToAdd = (POINTS_CONFIG[action] || 0) * value;
        const newPoints = (userData.points || 0) + pointsToAdd;
        
        const newLevelNumber = getLevel(newPoints);
        const newLevelName = getLevelName(newLevelNumber);
  
        const updateData: { [key: string]: any } = {
          points: newPoints,
          level: newLevelName,
        };
  
        transaction.update(userDocRef, updateData);
      });
    } catch (error) {
      console.error(`Gamification Error updating reaction stats for ${reactionType}:`, error);
    }
  };
  .................................................................
  api.ts

  // src/lib/api.ts
import type { Article, Category, StrapiResponse, Team, Post, SinglePage, ClubPage, ForumCategory, Comment } from '@/types';
import { db } from './firebase';
import { 
    collection, getDocs, addDoc, doc, updateDoc, deleteDoc, query, 
    where, orderBy, runTransaction, getDoc, setDoc, increment
} from "firebase/firestore";
import { updateUserStats, GamificationAction } from './gamification';
import qs from 'qs';

// --- HELPERS ---
const API_URL = 'https://supreme-basket-665350ebeb.strapiapp.com';

export function getStrapiURL(path = ""): string {
  if (path.startsWith('http')) return path;
  return `${API_URL}${path}`;
}

function processStrapiResponse(data: any): any {
  if (data === null || data === undefined) return null;
  if (data.data) return processStrapiResponse(data.data);
  if (data.attributes) {
    const flattened = { id: data.id, ...data.attributes };
    for (const key in flattened) {
        flattened[key] = processStrapiResponse(flattened[key]);
    }
    return flattened;
  }
  if (Array.isArray(data)) return data.map(item => processStrapiResponse(item));
  return data;
}

async function fetchAPI(path: string, urlParamsObject = {}, options = {}): Promise<any> {
  try {
    const mergedOptions = { headers: { 'Content-Type': 'application/json' }, ...options };
    const queryString = qs.stringify(urlParamsObject, { encodeValuesOnly: true });
    const requestUrl = getStrapiURL(`/api${path}${queryString ? `?${queryString}` : ''}`);
    const response = await fetch(requestUrl, mergedOptions);
    if (!response.ok) {
        console.error('Response not OK for URL:', requestUrl);
        console.error('Response status:', response.status);
        console.error('Response text:', await response.text());
        throw new Error(`An error occurred please try again`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(error);
    throw new Error('Failed to fetch API data. Please check the network connection.');
  }
}

const slugify = (text: string): string => {
  return text.toString().toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^\w\-]+/g, '')
    .replace(/\-\-+/g, '-')
    .replace(/^-+/, '')
    .replace(/-+$/, '');
}

// --- STRAPI API FUNCTIONS ---
export async function getArticles(params?: any): Promise<StrapiResponse<Article[]>> {
    const urlParams = params || { populate: { cover: true, category: true }, sort: { publishedAt: 'desc' } };
    const response = await fetchAPI('/articles', urlParams);
    return { ...response, data: processStrapiResponse(response.data) };
}
export async function getLatestArticles(limit: number): Promise<Article[]> {
  const params = { 
    populate: { 
      cover: true, 
      category: true 
    }, 
    sort: { publishedAt: 'desc' }, 
    pagination: { limit } 
  };
  const response = await fetchAPI('/articles', params);
  return processStrapiResponse(response.data);
}
export async function getArticleBySlug(slug: string): Promise<Article | null> {
    const params = { filters: { slug: { $eq: slug } }, populate: { blocks: { populate: '*' }, cover: true, category: true, author: true } };
    const articlesResponse = await fetchAPI('/articles', params);
    const articles = processStrapiResponse(articlesResponse.data);
    return articles && articles.length > 0 ? articles[0] : null;
}
export async function getSinglePage(page: string): Promise<SinglePage | null> {
    const params = { populate: { blocks: { populate: '*' } } };
    const pageResponse = await fetchAPI(`/${page}`, params);
    return processStrapiResponse(pageResponse.data);
}
export async function getCategories(): Promise<StrapiResponse<Category[]>> {
    const response = await fetchAPI('/categories');
    return { ...response, data: processStrapiResponse(response.data) };
}
export async function getCategoriesForFooter(): Promise<Category[]> {
  const params = { filters: { showInFooter: { $eq: true } }, sort: { order: 'asc' } };
  const response = await fetchAPI('/categories', params);
  return processStrapiResponse(response.data);
}
export async function getArticlesByCategory(categorySlug: string): Promise<StrapiResponse<Article[]>> {
    const params = { filters: { category: { slug: { $eq: categorySlug } } }, populate: { cover: true, category: true }, sort: { publishedAt: 'desc' } };
    const response = await fetchAPI('/articles', params);
    return { ...response, data: processStrapiResponse(response.data) };
}
export async function getClubPageBySlug(slug: string): Promise<ClubPage | null> {
    const params = { filters: { slug: { $eq: slug } }, populate: { logo: true, banner: true, menuItems: true, category: true } };
    const clubPageResponse = await fetchAPI('/club-pages', params);
    const pages = processStrapiResponse(clubPageResponse.data);
    return pages && pages.length > 0 ? pages[0] : null;
}

// --- FIRESTORE API FUNCTIONS ---

// --- Article Reactions ---
export const logArticleReaction = async (userId: string, articleId: string, type: 'like' | 'dislike'): Promise<void> => {
    const reactionRef = doc(db, 'articleReactions', `${userId}_${articleId}`);
    const statsRef = doc(db, 'articleStats', articleId);

    await runTransaction(db, async (transaction) => {
        const reactionDoc = await transaction.get(reactionRef);
        if (reactionDoc.exists()) {
            throw new Error("User has already reacted to this article.");
        }

        transaction.set(reactionRef, { userId, articleId, type, createdAt: new Date() });

        const statsUpdate = type === 'like' 
            ? { likeCount: increment(1) } 
            : { dislikeCount: increment(1) };
        transaction.set(statsRef, statsUpdate, { merge: true });
    });

    const action = type === 'like' ? 'ARTICLE_LIKE' : 'ARTICLE_DISLIKE';
    await updateUserStats(userId, action);
};

export const getUserArticleReaction = async (userId: string, articleId: string): Promise<'like' | 'dislike' | null> => {
    const reactionRef = doc(db, 'articleReactions', `${userId}_${articleId}`);
    const docSnap = await getDoc(reactionRef);
    if (docSnap.exists()) {
        return docSnap.data().type;
    }
    return null;
};

export const getArticleStats = async (articleId: string): Promise<{ likeCount: number, dislikeCount: number }> => {
    const statsRef = doc(db, 'articleStats', articleId);
    const docSnap = await getDoc(statsRef);
    if (docSnap.exists()) {
        return docSnap.data() as { likeCount: number, dislikeCount: number };
    }
    return { likeCount: 0, dislikeCount: 0 };
};

const getAggregatedStats = async () => {
    const postsSnapshot = await getDocs(collection(db, 'posts'));
    const posts = postsSnapshot.docs.map(doc => doc.data() as Post);
    return posts.reduce((acc, post) => {
        if (post.categoryId) {
            if (!acc[post.categoryId]) acc[post.categoryId] = { postCount: 0, lastPost: null };
            acc[post.categoryId].postCount++;
            if (!acc[post.categoryId].lastPost || post.createdAt.toMillis() > (acc[post.categoryId].lastPost?.createdAt.toMillis() || 0)) {
                acc[post.categoryId].lastPost = post;
            }
        }
        return acc;
    }, {} as { [key: string]: { postCount: number; lastPost: Post | null } });
}

export const getTeams = async (): Promise<Team[]> => {
    const stats = await getAggregatedStats();
    const teamsSnapshot = await getDocs(collection(db, 'teams'));
    return teamsSnapshot.docs.map(doc => {
        const teamData = { id: doc.id, ...doc.data() } as Team;
        const teamStats = stats[doc.id] || { postCount: 0, lastPost: null };
        return {
            ...teamData,
            postCount: teamStats.postCount,
            lastPost: teamStats.lastPost ? { title: teamStats.lastPost.title, createdAt: teamStats.lastPost.createdAt } : null,
        };
    });
};
export const addTeam = async (team: Omit<Team, 'id'>): Promise<Team> => {
    const docRef = await addDoc(collection(db, "teams"), team);
    return { id: docRef.id, ...team };
};
export const updateTeam = async (teamId: string, teamData: Partial<Omit<Team, 'id'>>): Promise<void> => {
    await updateDoc(doc(db, 'teams', teamId), teamData);
};
export const deleteTeam = async (teamId: string): Promise<void> => {
    await deleteDoc(doc(db, 'teams', teamId));
};

export const getForumCategories = async (): Promise<ForumCategory[]> => {
    const stats = await getAggregatedStats();
    const categoriesSnapshot = await getDocs(query(collection(db, 'forum_categories'), orderBy('name')));
    return categoriesSnapshot.docs.map(doc => {
        const categoryData = { id: doc.id, ...doc.data() } as ForumCategory;
        const categoryStats = stats[doc.id] || { postCount: 0, lastPost: null };
        return {
            ...categoryData,
            postCount: categoryStats.postCount,
            lastPost: categoryStats.lastPost ? { title: categoryStats.lastPost.title, createdAt: categoryStats.lastPost.createdAt } : null,
        };
    });
};
export const addForumCategory = async (category: Pick<ForumCategory, 'name' | 'description' | 'isPinned'>): Promise<ForumCategory> => {
    const slug = slugify(category.name);
    const docRef = await addDoc(collection(db, 'forum_categories'), { ...category, slug });
    return { id: docRef.id, slug, ...category };
};
export const updateForumCategory = async (categoryId: string, categoryData: Partial<Pick<ForumCategory, 'name' | 'description' | 'isPinned'>>): Promise<void> => {
    const dataToUpdate: Partial<ForumCategory> = { ...categoryData };
    if (categoryData.name) dataToUpdate.slug = slugify(categoryData.name);
    await updateDoc(doc(db, 'forum_categories', categoryId), dataToUpdate);
};
export const deleteForumCategory = async (categoryId: string): Promise<void> => {
    await deleteDoc(doc(db, 'forum_categories', categoryId));
};

const getGamificationActionForReceiver = (reactionType: string): GamificationAction => {
    switch (reactionType) {
        case 'like': return 'RECEIVE_LIKE';
        case 'golazo': return 'RECEIVE_GOLAZO';
        case 'redcard': return 'RECEIVE_RED_CARD';
        default: throw new Error(`Invalid reaction type: ${reactionType}`);
    }
}

export const addReaction = async (
    context: 'forum' | 'article',
    contentId: { postId: string, commentId?: string | null },
    reactionType: 'like' | 'golazo' | 'redcard',
    userId: string,
    authorId: string,
): Promise<{ newReactions: { [key: string]: string[] }, userReaction: string | null }> => {
    const docRef = context === 'forum'
        ? (contentId.commentId ? doc(db, 'posts', contentId. postId, 'comments', contentId.commentId) : doc(db, 'posts', contentId.postId))
        : doc(db, 'articleComments', contentId.commentId!);

    try {
        let finalReactions: { [key: string]: string[] } = {};
        let finalUserReaction: string | null = null;
        let gaveNewReaction = false;
        let removedOldReaction = false;
        let oldReactionType: string | null = null;
        
        await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(docRef);
            if (!docSnap.exists()) throw new Error("Document does not exist!");

            const data = docSnap.data() as Post | Comment;
            const currentReactions = data.reactions || {};
            const userReactions = data.userReactions || {};
            const existingReaction = userReactions[userId];
            
            if (existingReaction) {
                oldReactionType = existingReaction;
                removedOldReaction = true;
                if (Array.isArray(currentReactions[existingReaction])) {
                    currentReactions[existingReaction] = currentReactions[existingReaction].filter(uid => uid !== userId);
                }
            }

            if (existingReaction !== reactionType) {
                if (!Array.isArray(currentReactions[reactionType])) currentReactions[reactionType] = [];
                currentReactions[reactionType].push(userId);
                userReactions[userId] = reactionType;
                finalUserReaction = reactionType;
                gaveNewReaction = true;
            } else {
                delete userReactions[userId];
                finalUserReaction = null;
            }
            
            transaction.update(docRef, { reactions: currentReactions, userReactions });
            finalReactions = currentReactions;
        });

        if (removedOldReaction && oldReactionType) {
            await updateUserStats(authorId, getGamificationActionForReceiver(oldReactionType), 'subtract');
            // **FIX**: Penalize the user who removed the reaction
            await updateUserStats(userId, 'GIVE_REACTION', 'subtract');
        }
        if (gaveNewReaction) {
            await updateUserStats(authorId, getGamificationActionForReceiver(reactionType), 'add');
            await updateUserStats(userId, 'GIVE_REACTION', 'add');
        }

        return { newReactions: finalReactions, userReaction: finalUserReaction };

    } catch (error) {
        console.error("Error processing reaction transaction:", error);
        if (error instanceof Error && error.message.includes("limit")) {
            throw new Error("L√≠mite diario de reacciones alcanzado.");
        }
        throw new Error("Failed to process reaction.");
    }
};
